<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ASCII Saturn — rotating</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#0f1720;
    --muted:#9aa7b2;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;padding:28px;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:18px;box-shadow:0 6px 24px rgba(0,0,0,0.6);max-width:1000px;width:100%}
  .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
  label{font-size:13px;color:var(--muted)}
  input[type=range]{accent-color:#caa45a}
  button{background:#1b2430;color:#e6eef6;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
  button:active{transform:translateY(1px)}
  pre#screen{margin:0;background:transparent;white-space:pre;line-height:0.95;font-size:12px;overflow:auto;max-height:60vh;padding:12px;border-radius:8px}
  .help{font-size:13px;color:var(--muted);margin-top:8px}
  .footer{font-size:12px;color:var(--muted);margin-top:8px;text-align:center}
  .control-item{display:flex;flex-direction:column;gap:6px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card" role="region" aria-label="Saturn ASCII animation">
    <div class="controls" aria-hidden="false">
      <div class="control-item">
        <label for="sizeRange">Size (rows) <span id="sizeVal">28</span></label>
        <input id="sizeRange" type="range" min="14" max="48" value="28">
      </div>
      <div class="control-item">
        <label for="speedRange">Speed (rotation)</label>
        <input id="speedRange" type="range" min="0.2" max="3.0" step="0.1" value="1.0">
      </div>
      <div class="control-item">
        <label for="charSet">Shading</label>
        <select id="charSet" title="Choose shading characters">
          <option value=" .:-=+*#%@">Smooth</option>
          <option value=" `.^,;:!+xXO0#@">Rough</option>
          <option value=" .oO@">Blocky</option>
        </select>
      </div>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <button id="playPause">Pause</button>
        <button id="resetBtn">Reset</button>
      </div>
    </div>

    <pre id="screen" aria-live="off" role="img"></pre>
    <div class="help">Tip: increase size for smoother planet, increase speed for faster rotation.</div>
    <div class="footer">ASCII Saturn — simulated x-axis rotation • Use monospace for best results</div>
  </div>
</div>

<script>
/*
  ASCII Saturn animation
  - Sphere shading based on simple Lambert-like lighting
  - Rings drawn as ellipse slices with a tilt that changes with time to simulate rotation on planet's x-axis
  - Controls: size, speed, shading chars, pause/reset
*/

(() => {
  const screen = document.getElementById('screen');
  const sizeRange = document.getElementById('sizeRange');
  const speedRange = document.getElementById('speedRange');
  const playPause = document.getElementById('playPause');
  const resetBtn = document.getElementById('resetBtn');
  const charSetSel = document.getElementById('charSet');
  const sizeVal = document.getElementById('sizeVal');

  let running = true;
  let tStart = performance.now();
  let lastTime = tStart;

  // settings
  let rows = parseInt(sizeRange.value,10); // vertical resolution
  let aspect = 2.0; // character width/height ratio compensation
  let cols = Math.round(rows * aspect * 2.4); // columns — wider to fit rings
  let speed = parseFloat(speedRange.value); // rotation speed multiplier
  let shadeChars = charSetSel.value; // gradient characters from light -> dark

  sizeRange.addEventListener('input', () => {
    rows = parseInt(sizeRange.value,10);
    sizeVal.textContent = rows;
    cols = Math.round(rows * aspect * 2.4);
    // reduce flicker by redrawing immediately
    drawFrame((performance.now()-tStart)/1000 * speed);
  });

  speedRange.addEventListener('input', () => {
    speed = parseFloat(speedRange.value);
  });

  charSetSel.addEventListener('change', () => {
    shadeChars = charSetSel.value;
  });

  playPause.addEventListener('click', () => {
    running = !running;
    playPause.textContent = running ? 'Pause' : 'Play';
    if (running) {
      // resume loop
      tStart = performance.now() - (lastTime - tStart);
      requestAnimationFrame(loop);
    }
  });

  resetBtn.addEventListener('click', () => {
    // reset time / params
    tStart = performance.now();
    drawFrame(0);
  });

  // helper: map value from a..b to 0..1
  function norm(x, a, b){ return (x - a) / (b - a); }

  // render single frame at time t (seconds)
  function drawFrame(t) {
    // planet geometry
    const R = 0.9; // normalized planet radius
    const ringInner = 1.15; // ring inner radius relative to planet radius
    const ringOuter = 2.0;  // ring outer radius
    // rotation angle that affects ring tilt to simulate x-axis rotation
    const ang = t * 0.6 * speed; // base angle; speed multiplies
    // tilt oscillates between -0.6..+0.6 (radians) to mimic the axis tilt/rotation
    const tilt = Math.sin(ang) * 0.66;

    // light direction (simple)
    const L = normalize([0.6, 0.8, 0.5]); // light coming from above-right

    let out = '';
    // iterate rows top->bottom
    for (let yi = 0; yi < rows; yi++) {
      let y = ( (yi / (rows-1)) * 2 - 1); // -1..+1
      // increase vertical compression for nicer look
      for (let xi = 0; xi < cols; xi++) {
        let x = ((xi / (cols-1)) * 2 - 1) * (cols/rows) * 0.6; // scale to fit
        // compute distance in planet-centered coords where z is out of screen
        // sphere check: x^2 + y^2 + z^2 <= R^2  => z = sqrt(R^2 - x^2 - y^2)
        const d2 = x*x + y*y;
        let ch = ' ';
        if (d2 <= R*R) {
          // point is on planet surface; compute normal
          const z = Math.sqrt(R*R - d2);
          const N = normalize([x, y, z]);
          // simple diffuse:
          const diffuse = Math.max(0, dot(N, L));
          // add subtle ambient
          const amb = 0.12;
          const val = Math.min(1, amb + diffuse * 0.95);
          ch = shadeChar(val);
        } else {
          // maybe ring? compute ring coordinates in ring plane tilted by 'tilt' around x-axis
          // rotate the point (x,y,0) by -tilt around x to map to ring plane coordinates:
          // rotation around x: y' = y*cos - z*sin ; z' = y*sin + z*cos. Here z is 0 for screen plane
          const yprime = y * Math.cos(tilt) - 0 * Math.sin(tilt);
          const zprime = y * Math.sin(tilt) + 0 * Math.cos(tilt);
          // compute radial distance from origin in the ring plane
          const rplane = Math.sqrt(x*x + zprime*zprime);
          if (rplane >= ringInner && rplane <= ringOuter) {
            // further modulate brightness by where within ring thickness and by angle
            // make the ring partly occluded by planet (simple occlusion test)
            // if the ring point projects behind the sphere (i.e., zprime^2 + x^2 < R^2 and ring is behind)
            // we check if the ring is behind the sphere by comparing z depth from ring plane rotation
            // approximate depth of ring element along viewer z-axis: small negative means behind
            const behind = ((x*x + y*y) < R*R && Math.cos(tilt) * y < 0);
            // shade ring based on distance from inner edge
            const tEdge = (rplane - ringInner) / (ringOuter - ringInner); // 0..1
            // make rings striped by slight sinusoidal bumps to look natural
            const stripe = 0.4 + 0.4*Math.sin(rplane*8.0 + ang*3.0 + x*6.0);
            let brightness = 0.25 + 0.75*(1 - Math.abs(tEdge - 0.5)) * stripe;
            // dim back rings a bit
            if (behind) brightness *= 0.45;
            ch = shadeChar(brightness);
          } else {
            ch = ' ';
          }
        }
        out += ch;
      }
      out += '\n';
    }

    screen.textContent = out;
  }

  // choose a character from shadeChars according to value 0..1 (0 light, 1 dark)
  function shadeChar(val) {
    // clamp
    val = Math.max(0, Math.min(1, val));
    // reverse order so higher value (bright) picks earlier / lighter char
    // but many gradients have leading space as first char — detect and handle
    const g = shadeChars;
    // If the gradient starts with a space, treat it as the lightest
    const n = g.length;
    // pick index: 0 -> lightest, n-1 -> darkest
    // we want brighter (val closer to 1) to be lighter, so invert:
    const idx = Math.floor((1 - val) * (n - 1) + 0.0001);
    return g[Math.max(0, Math.min(n-1, idx))];
  }

  // small vector helpers
  function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
  function len(a){ return Math.sqrt(dot(a,a)); }
  function normalize(a){
    const L = len(a) || 1e-6;
    return [a[0]/L, a[1]/L, a[2]/L];
  }

  function loop(now) {
    lastTime = now;
    if (!running) return;
    const t = (now - tStart)/1000;
    drawFrame(t);
    requestAnimationFrame(loop);
  }

  // draw initial frame
  drawFrame(0);
  requestAnimationFrame(loop);

})();
</script>
